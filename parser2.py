#!/usr/bin/env python3.8
# @generated by pegen from /home/oscarbucio/dev/Compiladores/grammar.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser
# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: file_input
        mark = self._mark()
        if (
            (file_input := self.file_input())
        ):
            return file_input
        self._reset(mark)
        return None

    @memoize
    def file_input(self) -> Optional[Any]:
        # file_input: ((NEWLINE | stmt))* $
        mark = self._mark()
        if (
            (_loop0_1 := self._loop0_1(),)
            and
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return [_loop0_1, _endmarker]
        self._reset(mark)
        return None

    @memoize
    def decorator(self) -> Optional[Any]:
        # decorator: '@' dotted_name ['(' arglist? ')'] NEWLINE
        mark = self._mark()
        if (
            (literal := self.expect('@'))
            and
            (dotted_name := self.dotted_name())
            and
            (opt := self._tmp_2(),)
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return [literal, dotted_name, opt, _newline]
        self._reset(mark)
        return None

    @memoize
    def decorators(self) -> Optional[Any]:
        # decorators: decorator+
        mark = self._mark()
        if (
            (_loop1_3 := self._loop1_3())
        ):
            return _loop1_3
        self._reset(mark)
        return None

    @memoize
    def decorated(self) -> Optional[Any]:
        # decorated: decorators (classdef | funcdef | async_funcdef)
        mark = self._mark()
        if (
            (decorators := self.decorators())
            and
            (_tmp_4 := self._tmp_4())
        ):
            return [decorators, _tmp_4]
        self._reset(mark)
        return None

    @memoize
    def async_funcdef(self) -> Optional[Any]:
        # async_funcdef: ASYNC funcdef
        mark = self._mark()
        if (
            (_async := self.expect('ASYNC'))
            and
            (funcdef := self.funcdef())
        ):
            return [_async, funcdef]
        self._reset(mark)
        return None

    @memoize
    def funcdef(self) -> Optional[Any]:
        # funcdef: 'def' NAME parameters ['->' test] ':' TYPE_COMMENT? func_body_suite
        mark = self._mark()
        if (
            (literal := self.expect('def'))
            and
            (name := self.name())
            and
            (parameters := self.parameters())
            and
            (opt := self._tmp_5(),)
            and
            (literal_1 := self.expect(':'))
            and
            (opt_1 := self.type_comment(),)
            and
            (func_body_suite := self.func_body_suite())
        ):
            return [literal, name, parameters, opt, literal_1, opt_1, func_body_suite]
        self._reset(mark)
        return None

    @memoize
    def parameters(self) -> Optional[Any]:
        # parameters: '(' typedargslist? ')'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (opt := self.typedargslist(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def typedargslist(self) -> Optional[Any]:
        # typedargslist: (tfpdef ['=' test] ((',' TYPE_COMMENT? tfpdef ['=' test]))* ',' TYPE_COMMENT? '/' [',' [TYPE_COMMENT? tfpdef ['=' test] ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]) | '*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]) | (tfpdef ['=' test] ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]) | '*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?)
        mark = self._mark()
        if (
            (_tmp_6 := self._tmp_6())
        ):
            return _tmp_6
        self._reset(mark)
        if (
            (_tmp_7 := self._tmp_7())
        ):
            return _tmp_7
        self._reset(mark)
        return None

    @memoize
    def tfpdef(self) -> Optional[Any]:
        # tfpdef: NAME [':' test]
        mark = self._mark()
        if (
            (name := self.name())
            and
            (opt := self._tmp_8(),)
        ):
            return [name, opt]
        self._reset(mark)
        return None

    @memoize
    def varargslist(self) -> Optional[Any]:
        # varargslist: vfpdef ['=' test] ((',' vfpdef ['=' test]))* ',' '/' [',' [(vfpdef ['=' test] ((',' vfpdef ['=' test]))* [',' ['*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?]] | '*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?)]] | (vfpdef ['=' test] ((',' vfpdef ['=' test]))* [',' ['*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?]] | '*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?)
        mark = self._mark()
        if (
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_9(),)
            and
            (_loop0_10 := self._loop0_10(),)
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('/'))
            and
            (opt_1 := self._tmp_11(),)
        ):
            return [vfpdef, opt, _loop0_10, literal, literal_1, opt_1]
        self._reset(mark)
        if (
            (_tmp_12 := self._tmp_12())
        ):
            return _tmp_12
        self._reset(mark)
        return None

    @memoize
    def vfpdef(self) -> Optional[Any]:
        # vfpdef: NAME
        mark = self._mark()
        if (
            (name := self.name())
        ):
            return name
        self._reset(mark)
        return None

    @memoize
    def stmt(self) -> Optional[Any]:
        # stmt: simple_stmt | compound_stmt
        mark = self._mark()
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return simple_stmt
        self._reset(mark)
        if (
            (compound_stmt := self.compound_stmt())
        ):
            return compound_stmt
        self._reset(mark)
        return None

    @memoize
    def simple_stmt(self) -> Optional[Any]:
        # simple_stmt: small_stmt ((';' small_stmt))* ';'? NEWLINE
        mark = self._mark()
        if (
            (small_stmt := self.small_stmt())
            and
            (_loop0_13 := self._loop0_13(),)
            and
            (opt := self.expect(';'),)
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return [small_stmt, _loop0_13, opt, _newline]
        self._reset(mark)
        return None

    @memoize
    def small_stmt(self) -> Optional[Any]:
        # small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
        mark = self._mark()
        if (
            (expr_stmt := self.expr_stmt())
        ):
            return expr_stmt
        self._reset(mark)
        if (
            (del_stmt := self.del_stmt())
        ):
            return del_stmt
        self._reset(mark)
        if (
            (pass_stmt := self.pass_stmt())
        ):
            return pass_stmt
        self._reset(mark)
        if (
            (flow_stmt := self.flow_stmt())
        ):
            return flow_stmt
        self._reset(mark)
        if (
            (import_stmt := self.import_stmt())
        ):
            return import_stmt
        self._reset(mark)
        if (
            (global_stmt := self.global_stmt())
        ):
            return global_stmt
        self._reset(mark)
        if (
            (nonlocal_stmt := self.nonlocal_stmt())
        ):
            return nonlocal_stmt
        self._reset(mark)
        if (
            (assert_stmt := self.assert_stmt())
        ):
            return assert_stmt
        self._reset(mark)
        return None

    @memoize
    def expr_stmt(self) -> Optional[Any]:
        # expr_stmt: testlist_star_expr (annassign | augassign (yield_expr | testlist) | [(('=' (yield_expr | testlist_star_expr)))+ TYPE_COMMENT?])
        mark = self._mark()
        if (
            (testlist_star_expr := self.testlist_star_expr())
            and
            (_tmp_14 := self._tmp_14())
        ):
            return [testlist_star_expr, _tmp_14]
        self._reset(mark)
        return None

    @memoize
    def annassign(self) -> Optional[Any]:
        # annassign: ':' test ['=' (yield_expr | testlist_star_expr)]
        mark = self._mark()
        if (
            (literal := self.expect(':'))
            and
            (test := self.test())
            and
            (opt := self._tmp_15(),)
        ):
            return [literal, test, opt]
        self._reset(mark)
        return None

    @memoize
    def testlist_star_expr(self) -> Optional[Any]:
        # testlist_star_expr: (test | star_expr) ((',' (test | star_expr)))* ','?
        mark = self._mark()
        if (
            (_tmp_16 := self._tmp_16())
            and
            (_loop0_17 := self._loop0_17(),)
            and
            (opt := self.expect(','),)
        ):
            return [_tmp_16, _loop0_17, opt]
        self._reset(mark)
        return None

    @memoize
    def augassign(self) -> Optional[Any]:
        # augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        mark = self._mark()
        if (
            (literal := self.expect('+='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('-='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('*='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('@='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('/='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('%='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('&='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('|='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('^='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('<<='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('>>='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('**='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('//='))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def del_stmt(self) -> Optional[Any]:
        # del_stmt: 'del' exprlist
        mark = self._mark()
        if (
            (literal := self.expect('del'))
            and
            (exprlist := self.exprlist())
        ):
            return [literal, exprlist]
        self._reset(mark)
        return None

    @memoize
    def pass_stmt(self) -> Optional[Any]:
        # pass_stmt: 'pass'
        mark = self._mark()
        if (
            (literal := self.expect('pass'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def flow_stmt(self) -> Optional[Any]:
        # flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
        mark = self._mark()
        if (
            (break_stmt := self.break_stmt())
        ):
            return break_stmt
        self._reset(mark)
        if (
            (continue_stmt := self.continue_stmt())
        ):
            return continue_stmt
        self._reset(mark)
        if (
            (return_stmt := self.return_stmt())
        ):
            return return_stmt
        self._reset(mark)
        if (
            (raise_stmt := self.raise_stmt())
        ):
            return raise_stmt
        self._reset(mark)
        if (
            (yield_stmt := self.yield_stmt())
        ):
            return yield_stmt
        self._reset(mark)
        return None

    @memoize
    def break_stmt(self) -> Optional[Any]:
        # break_stmt: 'break'
        mark = self._mark()
        if (
            (literal := self.expect('break'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def continue_stmt(self) -> Optional[Any]:
        # continue_stmt: 'continue'
        mark = self._mark()
        if (
            (literal := self.expect('continue'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def return_stmt(self) -> Optional[Any]:
        # return_stmt: 'return' testlist_star_expr?
        mark = self._mark()
        if (
            (literal := self.expect('return'))
            and
            (opt := self.testlist_star_expr(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def yield_stmt(self) -> Optional[Any]:
        # yield_stmt: yield_expr
        mark = self._mark()
        if (
            (yield_expr := self.yield_expr())
        ):
            return yield_expr
        self._reset(mark)
        return None

    @memoize
    def raise_stmt(self) -> Optional[Any]:
        # raise_stmt: 'raise' [test ['from' test]]
        mark = self._mark()
        if (
            (literal := self.expect('raise'))
            and
            (opt := self._tmp_18(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def import_stmt(self) -> Optional[Any]:
        # import_stmt: import_name | import_from
        mark = self._mark()
        if (
            (import_name := self.import_name())
        ):
            return import_name
        self._reset(mark)
        if (
            (import_from := self.import_from())
        ):
            return import_from
        self._reset(mark)
        return None

    @memoize
    def import_name(self) -> Optional[Any]:
        # import_name: 'import' dotted_as_names
        mark = self._mark()
        if (
            (literal := self.expect('import'))
            and
            (dotted_as_names := self.dotted_as_names())
        ):
            return [literal, dotted_as_names]
        self._reset(mark)
        return None

    @memoize
    def import_from(self) -> Optional[Any]:
        # import_from: 'from' ((('.' | '...'))* dotted_name | (('.' | '...'))+) 'import' ('*' | '(' import_as_names ')' | import_as_names)
        mark = self._mark()
        if (
            (literal := self.expect('from'))
            and
            (_tmp_19 := self._tmp_19())
            and
            (literal_1 := self.expect('import'))
            and
            (_tmp_20 := self._tmp_20())
        ):
            return [literal, _tmp_19, literal_1, _tmp_20]
        self._reset(mark)
        return None

    @memoize
    def import_as_name(self) -> Optional[Any]:
        # import_as_name: NAME ['as' NAME]
        mark = self._mark()
        if (
            (name := self.name())
            and
            (opt := self._tmp_21(),)
        ):
            return [name, opt]
        self._reset(mark)
        return None

    @memoize
    def dotted_as_name(self) -> Optional[Any]:
        # dotted_as_name: dotted_name ['as' NAME]
        mark = self._mark()
        if (
            (dotted_name := self.dotted_name())
            and
            (opt := self._tmp_22(),)
        ):
            return [dotted_name, opt]
        self._reset(mark)
        return None

    @memoize
    def import_as_names(self) -> Optional[Any]:
        # import_as_names: import_as_name ((',' import_as_name))* ','?
        mark = self._mark()
        if (
            (import_as_name := self.import_as_name())
            and
            (_loop0_23 := self._loop0_23(),)
            and
            (opt := self.expect(','),)
        ):
            return [import_as_name, _loop0_23, opt]
        self._reset(mark)
        return None

    @memoize
    def dotted_as_names(self) -> Optional[Any]:
        # dotted_as_names: dotted_as_name ((',' dotted_as_name))*
        mark = self._mark()
        if (
            (dotted_as_name := self.dotted_as_name())
            and
            (_loop0_24 := self._loop0_24(),)
        ):
            return [dotted_as_name, _loop0_24]
        self._reset(mark)
        return None

    @memoize
    def dotted_name(self) -> Optional[Any]:
        # dotted_name: NAME (('.' NAME))*
        mark = self._mark()
        if (
            (name := self.name())
            and
            (_loop0_25 := self._loop0_25(),)
        ):
            return [name, _loop0_25]
        self._reset(mark)
        return None

    @memoize
    def global_stmt(self) -> Optional[Any]:
        # global_stmt: 'global' NAME ((',' NAME))*
        mark = self._mark()
        if (
            (literal := self.expect('global'))
            and
            (name := self.name())
            and
            (_loop0_26 := self._loop0_26(),)
        ):
            return [literal, name, _loop0_26]
        self._reset(mark)
        return None

    @memoize
    def nonlocal_stmt(self) -> Optional[Any]:
        # nonlocal_stmt: 'nonlocal' NAME ((',' NAME))*
        mark = self._mark()
        if (
            (literal := self.expect('nonlocal'))
            and
            (name := self.name())
            and
            (_loop0_27 := self._loop0_27(),)
        ):
            return [literal, name, _loop0_27]
        self._reset(mark)
        return None

    @memoize
    def assert_stmt(self) -> Optional[Any]:
        # assert_stmt: 'assert' test [',' test]
        mark = self._mark()
        if (
            (literal := self.expect('assert'))
            and
            (test := self.test())
            and
            (opt := self._tmp_28(),)
        ):
            return [literal, test, opt]
        self._reset(mark)
        return None

    @memoize
    def compound_stmt(self) -> Optional[Any]:
        # compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
        mark = self._mark()
        if (
            (if_stmt := self.if_stmt())
        ):
            return if_stmt
        self._reset(mark)
        if (
            (while_stmt := self.while_stmt())
        ):
            return while_stmt
        self._reset(mark)
        if (
            (for_stmt := self.for_stmt())
        ):
            return for_stmt
        self._reset(mark)
        if (
            (try_stmt := self.try_stmt())
        ):
            return try_stmt
        self._reset(mark)
        if (
            (with_stmt := self.with_stmt())
        ):
            return with_stmt
        self._reset(mark)
        if (
            (funcdef := self.funcdef())
        ):
            return funcdef
        self._reset(mark)
        if (
            (classdef := self.classdef())
        ):
            return classdef
        self._reset(mark)
        if (
            (decorated := self.decorated())
        ):
            return decorated
        self._reset(mark)
        if (
            (async_stmt := self.async_stmt())
        ):
            return async_stmt
        self._reset(mark)
        return None

    @memoize
    def async_stmt(self) -> Optional[Any]:
        # async_stmt: ASYNC (funcdef | with_stmt | for_stmt)
        mark = self._mark()
        if (
            (_async := self.expect('ASYNC'))
            and
            (_tmp_29 := self._tmp_29())
        ):
            return [_async, _tmp_29]
        self._reset(mark)
        return None

    @memoize
    def if_stmt(self) -> Optional[Any]:
        # if_stmt: 'if' namedexpr_test ':' suite (('elif' namedexpr_test ':' suite))* ['else' ':' suite]
        mark = self._mark()
        if (
            (literal := self.expect('if'))
            and
            (namedexpr_test := self.namedexpr_test())
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
            and
            (_loop0_30 := self._loop0_30(),)
            and
            (opt := self._tmp_31(),)
        ):
            return [literal, namedexpr_test, literal_1, suite, _loop0_30, opt]
        self._reset(mark)
        return None

    @memoize
    def while_stmt(self) -> Optional[Any]:
        # while_stmt: 'while' namedexpr_test ':' suite ['else' ':' suite]
        mark = self._mark()
        if (
            (literal := self.expect('while'))
            and
            (namedexpr_test := self.namedexpr_test())
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
            and
            (opt := self._tmp_32(),)
        ):
            return [literal, namedexpr_test, literal_1, suite, opt]
        self._reset(mark)
        return None

    @memoize
    def for_stmt(self) -> Optional[Any]:
        # for_stmt: 'for' exprlist 'in' testlist ':' TYPE_COMMENT? suite ['else' ':' suite]
        mark = self._mark()
        if (
            (literal := self.expect('for'))
            and
            (exprlist := self.exprlist())
            and
            (literal_1 := self.expect('in'))
            and
            (testlist := self.testlist())
            and
            (literal_2 := self.expect(':'))
            and
            (opt := self.type_comment(),)
            and
            (suite := self.suite())
            and
            (opt_1 := self._tmp_33(),)
        ):
            return [literal, exprlist, literal_1, testlist, literal_2, opt, suite, opt_1]
        self._reset(mark)
        return None

    @memoize
    def try_stmt(self) -> Optional[Any]:
        # try_stmt: 'try' ':' suite (((except_clause ':' suite))+ ['else' ':' suite] ['finally' ':' suite] | 'finally' ':' suite)
        mark = self._mark()
        if (
            (literal := self.expect('try'))
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
            and
            (_tmp_34 := self._tmp_34())
        ):
            return [literal, literal_1, suite, _tmp_34]
        self._reset(mark)
        return None

    @memoize
    def with_stmt(self) -> Optional[Any]:
        # with_stmt: 'with' with_item ((',' with_item))* ':' TYPE_COMMENT? suite
        mark = self._mark()
        if (
            (literal := self.expect('with'))
            and
            (with_item := self.with_item())
            and
            (_loop0_35 := self._loop0_35(),)
            and
            (literal_1 := self.expect(':'))
            and
            (opt := self.type_comment(),)
            and
            (suite := self.suite())
        ):
            return [literal, with_item, _loop0_35, literal_1, opt, suite]
        self._reset(mark)
        return None

    @memoize
    def with_item(self) -> Optional[Any]:
        # with_item: test ['as' expr]
        mark = self._mark()
        if (
            (test := self.test())
            and
            (opt := self._tmp_36(),)
        ):
            return [test, opt]
        self._reset(mark)
        return None

    @memoize
    def except_clause(self) -> Optional[Any]:
        # except_clause: 'except' [test ['as' NAME]]
        mark = self._mark()
        if (
            (literal := self.expect('except'))
            and
            (opt := self._tmp_37(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def suite(self) -> Optional[Any]:
        # suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
        mark = self._mark()
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return simple_stmt
        self._reset(mark)
        if (
            (_newline := self.expect('NEWLINE'))
            and
            (_indent := self.expect('INDENT'))
            and
            (_loop1_38 := self._loop1_38())
            and
            (_dedent := self.expect('DEDENT'))
        ):
            return [_newline, _indent, _loop1_38, _dedent]
        self._reset(mark)
        return None

    @memoize
    def namedexpr_test(self) -> Optional[Any]:
        # namedexpr_test: test [':=' test]
        mark = self._mark()
        if (
            (test := self.test())
            and
            (opt := self._tmp_39(),)
        ):
            return [test, opt]
        self._reset(mark)
        return None

    @memoize
    def test(self) -> Optional[Any]:
        # test: or_test ['if' or_test 'else' test] | lambdef
        mark = self._mark()
        if (
            (or_test := self.or_test())
            and
            (opt := self._tmp_40(),)
        ):
            return [or_test, opt]
        self._reset(mark)
        if (
            (lambdef := self.lambdef())
        ):
            return lambdef
        self._reset(mark)
        return None

    @memoize
    def test_nocond(self) -> Optional[Any]:
        # test_nocond: or_test | lambdef_nocond
        mark = self._mark()
        if (
            (or_test := self.or_test())
        ):
            return or_test
        self._reset(mark)
        if (
            (lambdef_nocond := self.lambdef_nocond())
        ):
            return lambdef_nocond
        self._reset(mark)
        return None

    @memoize
    def lambdef(self) -> Optional[Any]:
        # lambdef: 'lambda' varargslist? ':' test
        mark = self._mark()
        if (
            (literal := self.expect('lambda'))
            and
            (opt := self.varargslist(),)
            and
            (literal_1 := self.expect(':'))
            and
            (test := self.test())
        ):
            return [literal, opt, literal_1, test]
        self._reset(mark)
        return None

    @memoize
    def lambdef_nocond(self) -> Optional[Any]:
        # lambdef_nocond: 'lambda' varargslist? ':' test_nocond
        mark = self._mark()
        if (
            (literal := self.expect('lambda'))
            and
            (opt := self.varargslist(),)
            and
            (literal_1 := self.expect(':'))
            and
            (test_nocond := self.test_nocond())
        ):
            return [literal, opt, literal_1, test_nocond]
        self._reset(mark)
        return None

    @memoize
    def or_test(self) -> Optional[Any]:
        # or_test: and_test (('or' and_test))*
        mark = self._mark()
        if (
            (and_test := self.and_test())
            and
            (_loop0_41 := self._loop0_41(),)
        ):
            return [and_test, _loop0_41]
        self._reset(mark)
        return None

    @memoize
    def and_test(self) -> Optional[Any]:
        # and_test: not_test (('and' not_test))*
        mark = self._mark()
        if (
            (not_test := self.not_test())
            and
            (_loop0_42 := self._loop0_42(),)
        ):
            return [not_test, _loop0_42]
        self._reset(mark)
        return None

    @memoize
    def not_test(self) -> Optional[Any]:
        # not_test: 'not' not_test | comparison
        mark = self._mark()
        if (
            (literal := self.expect('not'))
            and
            (not_test := self.not_test())
        ):
            return [literal, not_test]
        self._reset(mark)
        if (
            (comparison := self.comparison())
        ):
            return comparison
        self._reset(mark)
        return None

    @memoize
    def comparison(self) -> Optional[Any]:
        # comparison: expr ((comp_op expr))*
        mark = self._mark()
        if (
            (expr := self.expr())
            and
            (_loop0_43 := self._loop0_43(),)
        ):
            return [expr, _loop0_43]
        self._reset(mark)
        return None

    @memoize
    def comp_op(self) -> Optional[Any]:
        # comp_op: '<' | '>' | '==' | '>=' | '<=' | '!=' | 'in' | 'not' 'in' | 'is' | 'is' 'not'
        mark = self._mark()
        if (
            (literal := self.expect('<'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('>'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('=='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('>='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('<='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('!='))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('in'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('not'))
            and
            (literal_1 := self.expect('in'))
        ):
            return [literal, literal_1]
        self._reset(mark)
        if (
            (literal := self.expect('is'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('is'))
            and
            (literal_1 := self.expect('not'))
        ):
            return [literal, literal_1]
        self._reset(mark)
        return None

    @memoize
    def star_expr(self) -> Optional[Any]:
        # star_expr: '*' expr
        mark = self._mark()
        if (
            (literal := self.expect('*'))
            and
            (expr := self.expr())
        ):
            return [literal, expr]
        self._reset(mark)
        return None

    @memoize
    def expr(self) -> Optional[Any]:
        # expr: xor_expr (('|' xor_expr))*
        mark = self._mark()
        if (
            (xor_expr := self.xor_expr())
            and
            (_loop0_44 := self._loop0_44(),)
        ):
            return [xor_expr, _loop0_44]
        self._reset(mark)
        return None

    @memoize
    def xor_expr(self) -> Optional[Any]:
        # xor_expr: and_expr (('^' and_expr))*
        mark = self._mark()
        if (
            (and_expr := self.and_expr())
            and
            (_loop0_45 := self._loop0_45(),)
        ):
            return [and_expr, _loop0_45]
        self._reset(mark)
        return None

    @memoize
    def and_expr(self) -> Optional[Any]:
        # and_expr: shift_expr (('&' shift_expr))*
        mark = self._mark()
        if (
            (shift_expr := self.shift_expr())
            and
            (_loop0_46 := self._loop0_46(),)
        ):
            return [shift_expr, _loop0_46]
        self._reset(mark)
        return None

    @memoize
    def shift_expr(self) -> Optional[Any]:
        # shift_expr: arith_expr ((('<<' | '>>') arith_expr))*
        mark = self._mark()
        if (
            (arith_expr := self.arith_expr())
            and
            (_loop0_47 := self._loop0_47(),)
        ):
            return [arith_expr, _loop0_47]
        self._reset(mark)
        return None

    @memoize
    def arith_expr(self) -> Optional[Any]:
        # arith_expr: term ((('+' | '-') term))*
        mark = self._mark()
        if (
            (term := self.term())
            and
            (_loop0_48 := self._loop0_48(),)
        ):
            return [term, _loop0_48]
        self._reset(mark)
        return None

    @memoize
    def term(self) -> Optional[Any]:
        # term: factor ((('*' | '@' | '/' | '%' | '//') factor))*
        mark = self._mark()
        if (
            (factor := self.factor())
            and
            (_loop0_49 := self._loop0_49(),)
        ):
            return [factor, _loop0_49]
        self._reset(mark)
        return None

    @memoize
    def factor(self) -> Optional[Any]:
        # factor: ('+' | '-' | '~') factor | power
        mark = self._mark()
        if (
            (_tmp_50 := self._tmp_50())
            and
            (factor := self.factor())
        ):
            return [_tmp_50, factor]
        self._reset(mark)
        if (
            (power := self.power())
        ):
            return power
        self._reset(mark)
        return None

    @memoize
    def power(self) -> Optional[Any]:
        # power: atom_expr ['**' factor]
        mark = self._mark()
        if (
            (atom_expr := self.atom_expr())
            and
            (opt := self._tmp_51(),)
        ):
            return [atom_expr, opt]
        self._reset(mark)
        return None

    @memoize
    def atom_expr(self) -> Optional[Any]:
        # atom_expr: AWAIT? atom trailer*
        mark = self._mark()
        if (
            (opt := self.expect('AWAIT'),)
            and
            (atom := self.atom())
            and
            (_loop0_52 := self._loop0_52(),)
        ):
            return [opt, atom, _loop0_52]
        self._reset(mark)
        return None

    @memoize
    def atom(self) -> Optional[Any]:
        # atom: '(' [yield_expr | testlist_comp] ')' | '[' testlist_comp? ']' | '{' dictorsetmaker? '}' | NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (opt := self._tmp_53(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self._reset(mark)
        if (
            (literal := self.expect('['))
            and
            (opt := self.testlist_comp(),)
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, opt, literal_1]
        self._reset(mark)
        if (
            (literal := self.expect('{'))
            and
            (opt := self.dictorsetmaker(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return [literal, opt, literal_1]
        self._reset(mark)
        if (
            (name := self.name())
        ):
            return name
        self._reset(mark)
        if (
            (number := self.number())
        ):
            return number
        self._reset(mark)
        if (
            (_loop1_54 := self._loop1_54())
        ):
            return _loop1_54
        self._reset(mark)
        if (
            (literal := self.expect('...'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('None'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('True'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('False'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def testlist_comp(self) -> Optional[Any]:
        # testlist_comp: (namedexpr_test | star_expr) (comp_for | ((',' (namedexpr_test | star_expr)))* ','?)
        mark = self._mark()
        if (
            (_tmp_55 := self._tmp_55())
            and
            (_tmp_56 := self._tmp_56())
        ):
            return [_tmp_55, _tmp_56]
        self._reset(mark)
        return None

    @memoize
    def trailer(self) -> Optional[Any]:
        # trailer: '(' arglist? ')' | '[' subscriptlist ']' | '.' NAME
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (opt := self.arglist(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self._reset(mark)
        if (
            (literal := self.expect('['))
            and
            (subscriptlist := self.subscriptlist())
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, subscriptlist, literal_1]
        self._reset(mark)
        if (
            (literal := self.expect('.'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def subscriptlist(self) -> Optional[Any]:
        # subscriptlist: subscript ((',' subscript))* ','?
        mark = self._mark()
        if (
            (subscript := self.subscript())
            and
            (_loop0_57 := self._loop0_57(),)
            and
            (opt := self.expect(','),)
        ):
            return [subscript, _loop0_57, opt]
        self._reset(mark)
        return None

    @memoize
    def subscript(self) -> Optional[Any]:
        # subscript: test | test? ':' test? sliceop?
        mark = self._mark()
        if (
            (test := self.test())
        ):
            return test
        self._reset(mark)
        if (
            (opt := self.test(),)
            and
            (literal := self.expect(':'))
            and
            (opt_1 := self.test(),)
            and
            (opt_2 := self.sliceop(),)
        ):
            return [opt, literal, opt_1, opt_2]
        self._reset(mark)
        return None

    @memoize
    def sliceop(self) -> Optional[Any]:
        # sliceop: ':' test?
        mark = self._mark()
        if (
            (literal := self.expect(':'))
            and
            (opt := self.test(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def exprlist(self) -> Optional[Any]:
        # exprlist: (expr | star_expr) ((',' (expr | star_expr)))* ','?
        mark = self._mark()
        if (
            (_tmp_58 := self._tmp_58())
            and
            (_loop0_59 := self._loop0_59(),)
            and
            (opt := self.expect(','),)
        ):
            return [_tmp_58, _loop0_59, opt]
        self._reset(mark)
        return None

    @memoize
    def testlist(self) -> Optional[Any]:
        # testlist: test ((',' test))* ','?
        mark = self._mark()
        if (
            (test := self.test())
            and
            (_loop0_60 := self._loop0_60(),)
            and
            (opt := self.expect(','),)
        ):
            return [test, _loop0_60, opt]
        self._reset(mark)
        return None

    @memoize
    def dictorsetmaker(self) -> Optional[Any]:
        # dictorsetmaker: ((test ':' test | '**' expr) (comp_for | ((',' (test ':' test | '**' expr)))* ','?)) | ((test | star_expr) (comp_for | ((',' (test | star_expr)))* ','?))
        mark = self._mark()
        if (
            (_tmp_61 := self._tmp_61())
        ):
            return _tmp_61
        self._reset(mark)
        if (
            (_tmp_62 := self._tmp_62())
        ):
            return _tmp_62
        self._reset(mark)
        return None

    @memoize
    def classdef(self) -> Optional[Any]:
        # classdef: 'class' NAME ['(' arglist? ')'] ':' suite
        mark = self._mark()
        if (
            (literal := self.expect('class'))
            and
            (name := self.name())
            and
            (opt := self._tmp_63(),)
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [literal, name, opt, literal_1, suite]
        self._reset(mark)
        return None

    @memoize
    def arglist(self) -> Optional[Any]:
        # arglist: argument ((',' argument))* ','?
        mark = self._mark()
        if (
            (argument := self.argument())
            and
            (_loop0_64 := self._loop0_64(),)
            and
            (opt := self.expect(','),)
        ):
            return [argument, _loop0_64, opt]
        self._reset(mark)
        return None

    @memoize
    def argument(self) -> Optional[Any]:
        # argument: test comp_for? | test ':=' test | test '=' test | '**' test | '*' test
        mark = self._mark()
        if (
            (test := self.test())
            and
            (opt := self.comp_for(),)
        ):
            return [test, opt]
        self._reset(mark)
        if (
            (test := self.test())
            and
            (literal := self.expect(':='))
            and
            (test_1 := self.test())
        ):
            return [test, literal, test_1]
        self._reset(mark)
        if (
            (test := self.test())
            and
            (literal := self.expect('='))
            and
            (test_1 := self.test())
        ):
            return [test, literal, test_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        if (
            (literal := self.expect('*'))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def comp_iter(self) -> Optional[Any]:
        # comp_iter: comp_for | comp_if
        mark = self._mark()
        if (
            (comp_for := self.comp_for())
        ):
            return comp_for
        self._reset(mark)
        if (
            (comp_if := self.comp_if())
        ):
            return comp_if
        self._reset(mark)
        return None

    @memoize
    def sync_comp_for(self) -> Optional[Any]:
        # sync_comp_for: 'for' exprlist 'in' or_test comp_iter?
        mark = self._mark()
        if (
            (literal := self.expect('for'))
            and
            (exprlist := self.exprlist())
            and
            (literal_1 := self.expect('in'))
            and
            (or_test := self.or_test())
            and
            (opt := self.comp_iter(),)
        ):
            return [literal, exprlist, literal_1, or_test, opt]
        self._reset(mark)
        return None

    @memoize
    def comp_for(self) -> Optional[Any]:
        # comp_for: ASYNC? sync_comp_for
        mark = self._mark()
        if (
            (opt := self.expect('ASYNC'),)
            and
            (sync_comp_for := self.sync_comp_for())
        ):
            return [opt, sync_comp_for]
        self._reset(mark)
        return None

    @memoize
    def comp_if(self) -> Optional[Any]:
        # comp_if: 'if' test_nocond comp_iter?
        mark = self._mark()
        if (
            (literal := self.expect('if'))
            and
            (test_nocond := self.test_nocond())
            and
            (opt := self.comp_iter(),)
        ):
            return [literal, test_nocond, opt]
        self._reset(mark)
        return None

    @memoize
    def yield_expr(self) -> Optional[Any]:
        # yield_expr: 'yield' yield_arg?
        mark = self._mark()
        if (
            (literal := self.expect('yield'))
            and
            (opt := self.yield_arg(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def yield_arg(self) -> Optional[Any]:
        # yield_arg: 'from' test | testlist_star_expr
        mark = self._mark()
        if (
            (literal := self.expect('from'))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        if (
            (testlist_star_expr := self.testlist_star_expr())
        ):
            return testlist_star_expr
        self._reset(mark)
        return None

    @memoize
    def func_body_suite(self) -> Optional[Any]:
        # func_body_suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT
        mark = self._mark()
        if (
            (simple_stmt := self.simple_stmt())
        ):
            return simple_stmt
        self._reset(mark)
        if (
            (_newline := self.expect('NEWLINE'))
            and
            (opt := self._tmp_65(),)
            and
            (_indent := self.expect('INDENT'))
            and
            (_loop1_66 := self._loop1_66())
            and
            (_dedent := self.expect('DEDENT'))
        ):
            return [_newline, opt, _indent, _loop1_66, _dedent]
        self._reset(mark)
        return None

    @memoize
    def typelist(self) -> Optional[Any]:
        # typelist: test ((',' test))* [',' ['*' test? ((',' test))* [',' '**' test] | '**' test]] | '*' test? ((',' test))* [',' '**' test] | '**' test
        mark = self._mark()
        if (
            (test := self.test())
            and
            (_loop0_67 := self._loop0_67(),)
            and
            (opt := self._tmp_68(),)
        ):
            return [test, _loop0_67, opt]
        self._reset(mark)
        if (
            (literal := self.expect('*'))
            and
            (opt := self.test(),)
            and
            (_loop0_69 := self._loop0_69(),)
            and
            (opt_1 := self._tmp_70(),)
        ):
            return [literal, opt, _loop0_69, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: (NEWLINE | stmt)
        mark = self._mark()
        children = []
        while (
            (_tmp_71 := self._tmp_71())
        ):
            children.append(_tmp_71)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_2(self) -> Optional[Any]:
        # _tmp_2: '(' arglist? ')'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (opt := self.arglist(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def _loop1_3(self) -> Optional[Any]:
        # _loop1_3: decorator
        mark = self._mark()
        children = []
        while (
            (decorator := self.decorator())
        ):
            children.append(decorator)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_4(self) -> Optional[Any]:
        # _tmp_4: classdef | funcdef | async_funcdef
        mark = self._mark()
        if (
            (classdef := self.classdef())
        ):
            return classdef
        self._reset(mark)
        if (
            (funcdef := self.funcdef())
        ):
            return funcdef
        self._reset(mark)
        if (
            (async_funcdef := self.async_funcdef())
        ):
            return async_funcdef
        self._reset(mark)
        return None

    @memoize
    def _tmp_5(self) -> Optional[Any]:
        # _tmp_5: '->' test
        mark = self._mark()
        if (
            (literal := self.expect('->'))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_6(self) -> Optional[Any]:
        # _tmp_6: tfpdef ['=' test] ((',' TYPE_COMMENT? tfpdef ['=' test]))* ',' TYPE_COMMENT? '/' [',' [TYPE_COMMENT? tfpdef ['=' test] ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]) | '*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]
        mark = self._mark()
        if (
            (tfpdef := self.tfpdef())
            and
            (opt := self._tmp_72(),)
            and
            (_loop0_73 := self._loop0_73(),)
            and
            (literal := self.expect(','))
            and
            (opt_1 := self.type_comment(),)
            and
            (literal_1 := self.expect('/'))
            and
            (opt_2 := self._tmp_74(),)
        ):
            return [tfpdef, opt, _loop0_73, literal, opt_1, literal_1, opt_2]
        self._reset(mark)
        return None

    @memoize
    def _tmp_7(self) -> Optional[Any]:
        # _tmp_7: tfpdef ['=' test] ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]) | '*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?
        mark = self._mark()
        if (
            (tfpdef := self.tfpdef())
            and
            (opt := self._tmp_75(),)
            and
            (_loop0_76 := self._loop0_76(),)
            and
            (_tmp_77 := self._tmp_77())
        ):
            return [tfpdef, opt, _loop0_76, _tmp_77]
        self._reset(mark)
        if (
            (literal := self.expect('*'))
            and
            (opt := self.tfpdef(),)
            and
            (_loop0_78 := self._loop0_78(),)
            and
            (_tmp_79 := self._tmp_79())
        ):
            return [literal, opt, _loop0_78, _tmp_79]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (tfpdef := self.tfpdef())
            and
            (opt := self.expect(','),)
            and
            (opt_1 := self.type_comment(),)
        ):
            return [literal, tfpdef, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_8(self) -> Optional[Any]:
        # _tmp_8: ':' test
        mark = self._mark()
        if (
            (literal := self.expect(':'))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_9(self) -> Optional[Any]:
        # _tmp_9: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_10(self) -> Optional[Any]:
        # _loop0_10: (',' vfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_80 := self._tmp_80())
        ):
            children.append(_tmp_80)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_11(self) -> Optional[Any]:
        # _tmp_11: ',' [(vfpdef ['=' test] ((',' vfpdef ['=' test]))* [',' ['*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?]] | '*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?)]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_81(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_12(self) -> Optional[Any]:
        # _tmp_12: vfpdef ['=' test] ((',' vfpdef ['=' test]))* [',' ['*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?]] | '*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?
        mark = self._mark()
        if (
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_82(),)
            and
            (_loop0_83 := self._loop0_83(),)
            and
            (opt_1 := self._tmp_84(),)
        ):
            return [vfpdef, opt, _loop0_83, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('*'))
            and
            (opt := self.vfpdef(),)
            and
            (_loop0_85 := self._loop0_85(),)
            and
            (opt_1 := self._tmp_86(),)
        ):
            return [literal, opt, _loop0_85, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self.expect(','),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop0_13(self) -> Optional[Any]:
        # _loop0_13: (';' small_stmt)
        mark = self._mark()
        children = []
        while (
            (_tmp_87 := self._tmp_87())
        ):
            children.append(_tmp_87)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: annassign | augassign (yield_expr | testlist) | [(('=' (yield_expr | testlist_star_expr)))+ TYPE_COMMENT?]
        mark = self._mark()
        if (
            (annassign := self.annassign())
        ):
            return annassign
        self._reset(mark)
        if (
            (augassign := self.augassign())
            and
            (_tmp_88 := self._tmp_88())
        ):
            return [augassign, _tmp_88]
        self._reset(mark)
        if (
            (opt := self._tmp_89(),)
        ):
            return opt
        self._reset(mark)
        return None

    @memoize
    def _tmp_15(self) -> Optional[Any]:
        # _tmp_15: '=' (yield_expr | testlist_star_expr)
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (_tmp_90 := self._tmp_90())
        ):
            return [literal, _tmp_90]
        self._reset(mark)
        return None

    @memoize
    def _tmp_16(self) -> Optional[Any]:
        # _tmp_16: test | star_expr
        mark = self._mark()
        if (
            (test := self.test())
        ):
            return test
        self._reset(mark)
        if (
            (star_expr := self.star_expr())
        ):
            return star_expr
        self._reset(mark)
        return None

    @memoize
    def _loop0_17(self) -> Optional[Any]:
        # _loop0_17: (',' (test | star_expr))
        mark = self._mark()
        children = []
        while (
            (_tmp_91 := self._tmp_91())
        ):
            children.append(_tmp_91)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_18(self) -> Optional[Any]:
        # _tmp_18: test ['from' test]
        mark = self._mark()
        if (
            (test := self.test())
            and
            (opt := self._tmp_92(),)
        ):
            return [test, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_19(self) -> Optional[Any]:
        # _tmp_19: (('.' | '...'))* dotted_name | (('.' | '...'))+
        mark = self._mark()
        if (
            (_loop0_93 := self._loop0_93(),)
            and
            (dotted_name := self.dotted_name())
        ):
            return [_loop0_93, dotted_name]
        self._reset(mark)
        if (
            (_loop1_94 := self._loop1_94())
        ):
            return _loop1_94
        self._reset(mark)
        return None

    @memoize
    def _tmp_20(self) -> Optional[Any]:
        # _tmp_20: '*' | '(' import_as_names ')' | import_as_names
        mark = self._mark()
        if (
            (literal := self.expect('*'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (import_as_names := self.import_as_names())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, import_as_names, literal_1]
        self._reset(mark)
        if (
            (import_as_names := self.import_as_names())
        ):
            return import_as_names
        self._reset(mark)
        return None

    @memoize
    def _tmp_21(self) -> Optional[Any]:
        # _tmp_21: 'as' NAME
        mark = self._mark()
        if (
            (literal := self.expect('as'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_22(self) -> Optional[Any]:
        # _tmp_22: 'as' NAME
        mark = self._mark()
        if (
            (literal := self.expect('as'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _loop0_23(self) -> Optional[Any]:
        # _loop0_23: (',' import_as_name)
        mark = self._mark()
        children = []
        while (
            (_tmp_95 := self._tmp_95())
        ):
            children.append(_tmp_95)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_24(self) -> Optional[Any]:
        # _loop0_24: (',' dotted_as_name)
        mark = self._mark()
        children = []
        while (
            (_tmp_96 := self._tmp_96())
        ):
            children.append(_tmp_96)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_25(self) -> Optional[Any]:
        # _loop0_25: ('.' NAME)
        mark = self._mark()
        children = []
        while (
            (_tmp_97 := self._tmp_97())
        ):
            children.append(_tmp_97)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_26(self) -> Optional[Any]:
        # _loop0_26: (',' NAME)
        mark = self._mark()
        children = []
        while (
            (_tmp_98 := self._tmp_98())
        ):
            children.append(_tmp_98)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_27(self) -> Optional[Any]:
        # _loop0_27: (',' NAME)
        mark = self._mark()
        children = []
        while (
            (_tmp_99 := self._tmp_99())
        ):
            children.append(_tmp_99)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_28(self) -> Optional[Any]:
        # _tmp_28: ',' test
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_29(self) -> Optional[Any]:
        # _tmp_29: funcdef | with_stmt | for_stmt
        mark = self._mark()
        if (
            (funcdef := self.funcdef())
        ):
            return funcdef
        self._reset(mark)
        if (
            (with_stmt := self.with_stmt())
        ):
            return with_stmt
        self._reset(mark)
        if (
            (for_stmt := self.for_stmt())
        ):
            return for_stmt
        self._reset(mark)
        return None

    @memoize
    def _loop0_30(self) -> Optional[Any]:
        # _loop0_30: ('elif' namedexpr_test ':' suite)
        mark = self._mark()
        children = []
        while (
            (_tmp_100 := self._tmp_100())
        ):
            children.append(_tmp_100)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_31(self) -> Optional[Any]:
        # _tmp_31: 'else' ':' suite
        mark = self._mark()
        if (
            (literal := self.expect('else'))
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [literal, literal_1, suite]
        self._reset(mark)
        return None

    @memoize
    def _tmp_32(self) -> Optional[Any]:
        # _tmp_32: 'else' ':' suite
        mark = self._mark()
        if (
            (literal := self.expect('else'))
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [literal, literal_1, suite]
        self._reset(mark)
        return None

    @memoize
    def _tmp_33(self) -> Optional[Any]:
        # _tmp_33: 'else' ':' suite
        mark = self._mark()
        if (
            (literal := self.expect('else'))
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [literal, literal_1, suite]
        self._reset(mark)
        return None

    @memoize
    def _tmp_34(self) -> Optional[Any]:
        # _tmp_34: ((except_clause ':' suite))+ ['else' ':' suite] ['finally' ':' suite] | 'finally' ':' suite
        mark = self._mark()
        if (
            (_loop1_101 := self._loop1_101())
            and
            (opt := self._tmp_102(),)
            and
            (opt_1 := self._tmp_103(),)
        ):
            return [_loop1_101, opt, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('finally'))
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [literal, literal_1, suite]
        self._reset(mark)
        return None

    @memoize
    def _loop0_35(self) -> Optional[Any]:
        # _loop0_35: (',' with_item)
        mark = self._mark()
        children = []
        while (
            (_tmp_104 := self._tmp_104())
        ):
            children.append(_tmp_104)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_36(self) -> Optional[Any]:
        # _tmp_36: 'as' expr
        mark = self._mark()
        if (
            (literal := self.expect('as'))
            and
            (expr := self.expr())
        ):
            return [literal, expr]
        self._reset(mark)
        return None

    @memoize
    def _tmp_37(self) -> Optional[Any]:
        # _tmp_37: test ['as' NAME]
        mark = self._mark()
        if (
            (test := self.test())
            and
            (opt := self._tmp_105(),)
        ):
            return [test, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop1_38(self) -> Optional[Any]:
        # _loop1_38: stmt
        mark = self._mark()
        children = []
        while (
            (stmt := self.stmt())
        ):
            children.append(stmt)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_39(self) -> Optional[Any]:
        # _tmp_39: ':=' test
        mark = self._mark()
        if (
            (literal := self.expect(':='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_40(self) -> Optional[Any]:
        # _tmp_40: 'if' or_test 'else' test
        mark = self._mark()
        if (
            (literal := self.expect('if'))
            and
            (or_test := self.or_test())
            and
            (literal_1 := self.expect('else'))
            and
            (test := self.test())
        ):
            return [literal, or_test, literal_1, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_41(self) -> Optional[Any]:
        # _loop0_41: ('or' and_test)
        mark = self._mark()
        children = []
        while (
            (_tmp_106 := self._tmp_106())
        ):
            children.append(_tmp_106)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_42(self) -> Optional[Any]:
        # _loop0_42: ('and' not_test)
        mark = self._mark()
        children = []
        while (
            (_tmp_107 := self._tmp_107())
        ):
            children.append(_tmp_107)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_43(self) -> Optional[Any]:
        # _loop0_43: (comp_op expr)
        mark = self._mark()
        children = []
        while (
            (_tmp_108 := self._tmp_108())
        ):
            children.append(_tmp_108)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_44(self) -> Optional[Any]:
        # _loop0_44: ('|' xor_expr)
        mark = self._mark()
        children = []
        while (
            (_tmp_109 := self._tmp_109())
        ):
            children.append(_tmp_109)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_45(self) -> Optional[Any]:
        # _loop0_45: ('^' and_expr)
        mark = self._mark()
        children = []
        while (
            (_tmp_110 := self._tmp_110())
        ):
            children.append(_tmp_110)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_46(self) -> Optional[Any]:
        # _loop0_46: ('&' shift_expr)
        mark = self._mark()
        children = []
        while (
            (_tmp_111 := self._tmp_111())
        ):
            children.append(_tmp_111)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_47(self) -> Optional[Any]:
        # _loop0_47: (('<<' | '>>') arith_expr)
        mark = self._mark()
        children = []
        while (
            (_tmp_112 := self._tmp_112())
        ):
            children.append(_tmp_112)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_48(self) -> Optional[Any]:
        # _loop0_48: (('+' | '-') term)
        mark = self._mark()
        children = []
        while (
            (_tmp_113 := self._tmp_113())
        ):
            children.append(_tmp_113)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_49(self) -> Optional[Any]:
        # _loop0_49: (('*' | '@' | '/' | '%' | '//') factor)
        mark = self._mark()
        children = []
        while (
            (_tmp_114 := self._tmp_114())
        ):
            children.append(_tmp_114)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_50(self) -> Optional[Any]:
        # _tmp_50: '+' | '-' | '~'
        mark = self._mark()
        if (
            (literal := self.expect('+'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('-'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('~'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_51(self) -> Optional[Any]:
        # _tmp_51: '**' factor
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (factor := self.factor())
        ):
            return [literal, factor]
        self._reset(mark)
        return None

    @memoize
    def _loop0_52(self) -> Optional[Any]:
        # _loop0_52: trailer
        mark = self._mark()
        children = []
        while (
            (trailer := self.trailer())
        ):
            children.append(trailer)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_53(self) -> Optional[Any]:
        # _tmp_53: yield_expr | testlist_comp
        mark = self._mark()
        if (
            (yield_expr := self.yield_expr())
        ):
            return yield_expr
        self._reset(mark)
        if (
            (testlist_comp := self.testlist_comp())
        ):
            return testlist_comp
        self._reset(mark)
        return None

    @memoize
    def _loop1_54(self) -> Optional[Any]:
        # _loop1_54: STRING
        mark = self._mark()
        children = []
        while (
            (string := self.string())
        ):
            children.append(string)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_55(self) -> Optional[Any]:
        # _tmp_55: namedexpr_test | star_expr
        mark = self._mark()
        if (
            (namedexpr_test := self.namedexpr_test())
        ):
            return namedexpr_test
        self._reset(mark)
        if (
            (star_expr := self.star_expr())
        ):
            return star_expr
        self._reset(mark)
        return None

    @memoize
    def _tmp_56(self) -> Optional[Any]:
        # _tmp_56: comp_for | ((',' (namedexpr_test | star_expr)))* ','?
        mark = self._mark()
        if (
            (comp_for := self.comp_for())
        ):
            return comp_for
        self._reset(mark)
        if (
            (_loop0_115 := self._loop0_115(),)
            and
            (opt := self.expect(','),)
        ):
            return [_loop0_115, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop0_57(self) -> Optional[Any]:
        # _loop0_57: (',' subscript)
        mark = self._mark()
        children = []
        while (
            (_tmp_116 := self._tmp_116())
        ):
            children.append(_tmp_116)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_58(self) -> Optional[Any]:
        # _tmp_58: expr | star_expr
        mark = self._mark()
        if (
            (expr := self.expr())
        ):
            return expr
        self._reset(mark)
        if (
            (star_expr := self.star_expr())
        ):
            return star_expr
        self._reset(mark)
        return None

    @memoize
    def _loop0_59(self) -> Optional[Any]:
        # _loop0_59: (',' (expr | star_expr))
        mark = self._mark()
        children = []
        while (
            (_tmp_117 := self._tmp_117())
        ):
            children.append(_tmp_117)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_60(self) -> Optional[Any]:
        # _loop0_60: (',' test)
        mark = self._mark()
        children = []
        while (
            (_tmp_118 := self._tmp_118())
        ):
            children.append(_tmp_118)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_61(self) -> Optional[Any]:
        # _tmp_61: (test ':' test | '**' expr) (comp_for | ((',' (test ':' test | '**' expr)))* ','?)
        mark = self._mark()
        if (
            (_tmp_119 := self._tmp_119())
            and
            (_tmp_120 := self._tmp_120())
        ):
            return [_tmp_119, _tmp_120]
        self._reset(mark)
        return None

    @memoize
    def _tmp_62(self) -> Optional[Any]:
        # _tmp_62: (test | star_expr) (comp_for | ((',' (test | star_expr)))* ','?)
        mark = self._mark()
        if (
            (_tmp_121 := self._tmp_121())
            and
            (_tmp_122 := self._tmp_122())
        ):
            return [_tmp_121, _tmp_122]
        self._reset(mark)
        return None

    @memoize
    def _tmp_63(self) -> Optional[Any]:
        # _tmp_63: '(' arglist? ')'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (opt := self.arglist(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def _loop0_64(self) -> Optional[Any]:
        # _loop0_64: (',' argument)
        mark = self._mark()
        children = []
        while (
            (_tmp_123 := self._tmp_123())
        ):
            children.append(_tmp_123)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_65(self) -> Optional[Any]:
        # _tmp_65: TYPE_COMMENT NEWLINE
        mark = self._mark()
        if (
            (type_comment := self.type_comment())
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return [type_comment, _newline]
        self._reset(mark)
        return None

    @memoize
    def _loop1_66(self) -> Optional[Any]:
        # _loop1_66: stmt
        mark = self._mark()
        children = []
        while (
            (stmt := self.stmt())
        ):
            children.append(stmt)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_67(self) -> Optional[Any]:
        # _loop0_67: (',' test)
        mark = self._mark()
        children = []
        while (
            (_tmp_124 := self._tmp_124())
        ):
            children.append(_tmp_124)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_68(self) -> Optional[Any]:
        # _tmp_68: ',' ['*' test? ((',' test))* [',' '**' test] | '**' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_125(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop0_69(self) -> Optional[Any]:
        # _loop0_69: (',' test)
        mark = self._mark()
        children = []
        while (
            (_tmp_126 := self._tmp_126())
        ):
            children.append(_tmp_126)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_70(self) -> Optional[Any]:
        # _tmp_70: ',' '**' test
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('**'))
            and
            (test := self.test())
        ):
            return [literal, literal_1, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_71(self) -> Optional[Any]:
        # _tmp_71: NEWLINE | stmt
        mark = self._mark()
        if (
            (_newline := self.expect('NEWLINE'))
        ):
            return _newline
        self._reset(mark)
        if (
            (stmt := self.stmt())
        ):
            return stmt
        self._reset(mark)
        return None

    @memoize
    def _tmp_72(self) -> Optional[Any]:
        # _tmp_72: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_73(self) -> Optional[Any]:
        # _loop0_73: (',' TYPE_COMMENT? tfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_127 := self._tmp_127())
        ):
            children.append(_tmp_127)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_74(self) -> Optional[Any]:
        # _tmp_74: ',' [TYPE_COMMENT? tfpdef ['=' test] ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]) | '*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_128(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_75(self) -> Optional[Any]:
        # _tmp_75: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_76(self) -> Optional[Any]:
        # _loop0_76: (',' TYPE_COMMENT? tfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_129 := self._tmp_129())
        ):
            children.append(_tmp_129)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_77(self) -> Optional[Any]:
        # _tmp_77: TYPE_COMMENT | [',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]
        mark = self._mark()
        if (
            (type_comment := self.type_comment())
        ):
            return type_comment
        self._reset(mark)
        if (
            (opt := self._tmp_130(),)
        ):
            return opt
        self._reset(mark)
        return None

    @memoize
    def _loop0_78(self) -> Optional[Any]:
        # _loop0_78: (',' TYPE_COMMENT? tfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_131 := self._tmp_131())
        ):
            children.append(_tmp_131)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_79(self) -> Optional[Any]:
        # _tmp_79: TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]
        mark = self._mark()
        if (
            (type_comment := self.type_comment())
        ):
            return type_comment
        self._reset(mark)
        if (
            (opt := self._tmp_132(),)
        ):
            return opt
        self._reset(mark)
        return None

    @memoize
    def _tmp_80(self) -> Optional[Any]:
        # _tmp_80: ',' vfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_133(),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_81(self) -> Optional[Any]:
        # _tmp_81: vfpdef ['=' test] ((',' vfpdef ['=' test]))* [',' ['*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?]] | '*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?
        mark = self._mark()
        if (
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_134(),)
            and
            (_loop0_135 := self._loop0_135(),)
            and
            (opt_1 := self._tmp_136(),)
        ):
            return [vfpdef, opt, _loop0_135, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('*'))
            and
            (opt := self.vfpdef(),)
            and
            (_loop0_137 := self._loop0_137(),)
            and
            (opt_1 := self._tmp_138(),)
        ):
            return [literal, opt, _loop0_137, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self.expect(','),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_82(self) -> Optional[Any]:
        # _tmp_82: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_83(self) -> Optional[Any]:
        # _loop0_83: (',' vfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_139 := self._tmp_139())
        ):
            children.append(_tmp_139)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_84(self) -> Optional[Any]:
        # _tmp_84: ',' ['*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_140(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop0_85(self) -> Optional[Any]:
        # _loop0_85: (',' vfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_141 := self._tmp_141())
        ):
            children.append(_tmp_141)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_86(self) -> Optional[Any]:
        # _tmp_86: ',' ['**' vfpdef ','?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_142(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_87(self) -> Optional[Any]:
        # _tmp_87: ';' small_stmt
        mark = self._mark()
        if (
            (literal := self.expect(';'))
            and
            (small_stmt := self.small_stmt())
        ):
            return [literal, small_stmt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_88(self) -> Optional[Any]:
        # _tmp_88: yield_expr | testlist
        mark = self._mark()
        if (
            (yield_expr := self.yield_expr())
        ):
            return yield_expr
        self._reset(mark)
        if (
            (testlist := self.testlist())
        ):
            return testlist
        self._reset(mark)
        return None

    @memoize
    def _tmp_89(self) -> Optional[Any]:
        # _tmp_89: (('=' (yield_expr | testlist_star_expr)))+ TYPE_COMMENT?
        mark = self._mark()
        if (
            (_loop1_143 := self._loop1_143())
            and
            (opt := self.type_comment(),)
        ):
            return [_loop1_143, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_90(self) -> Optional[Any]:
        # _tmp_90: yield_expr | testlist_star_expr
        mark = self._mark()
        if (
            (yield_expr := self.yield_expr())
        ):
            return yield_expr
        self._reset(mark)
        if (
            (testlist_star_expr := self.testlist_star_expr())
        ):
            return testlist_star_expr
        self._reset(mark)
        return None

    @memoize
    def _tmp_91(self) -> Optional[Any]:
        # _tmp_91: ',' (test | star_expr)
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (_tmp_144 := self._tmp_144())
        ):
            return [literal, _tmp_144]
        self._reset(mark)
        return None

    @memoize
    def _tmp_92(self) -> Optional[Any]:
        # _tmp_92: 'from' test
        mark = self._mark()
        if (
            (literal := self.expect('from'))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_93(self) -> Optional[Any]:
        # _loop0_93: ('.' | '...')
        mark = self._mark()
        children = []
        while (
            (_tmp_145 := self._tmp_145())
        ):
            children.append(_tmp_145)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_94(self) -> Optional[Any]:
        # _loop1_94: ('.' | '...')
        mark = self._mark()
        children = []
        while (
            (_tmp_146 := self._tmp_146())
        ):
            children.append(_tmp_146)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_95(self) -> Optional[Any]:
        # _tmp_95: ',' import_as_name
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (import_as_name := self.import_as_name())
        ):
            return [literal, import_as_name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_96(self) -> Optional[Any]:
        # _tmp_96: ',' dotted_as_name
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (dotted_as_name := self.dotted_as_name())
        ):
            return [literal, dotted_as_name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_97(self) -> Optional[Any]:
        # _tmp_97: '.' NAME
        mark = self._mark()
        if (
            (literal := self.expect('.'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_98(self) -> Optional[Any]:
        # _tmp_98: ',' NAME
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (name := self.name())
        ):
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_99(self) -> Optional[Any]:
        # _tmp_99: ',' NAME
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (name := self.name())
        ):
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_100(self) -> Optional[Any]:
        # _tmp_100: 'elif' namedexpr_test ':' suite
        mark = self._mark()
        if (
            (literal := self.expect('elif'))
            and
            (namedexpr_test := self.namedexpr_test())
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [literal, namedexpr_test, literal_1, suite]
        self._reset(mark)
        return None

    @memoize
    def _loop1_101(self) -> Optional[Any]:
        # _loop1_101: (except_clause ':' suite)
        mark = self._mark()
        children = []
        while (
            (_tmp_147 := self._tmp_147())
        ):
            children.append(_tmp_147)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_102(self) -> Optional[Any]:
        # _tmp_102: 'else' ':' suite
        mark = self._mark()
        if (
            (literal := self.expect('else'))
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [literal, literal_1, suite]
        self._reset(mark)
        return None

    @memoize
    def _tmp_103(self) -> Optional[Any]:
        # _tmp_103: 'finally' ':' suite
        mark = self._mark()
        if (
            (literal := self.expect('finally'))
            and
            (literal_1 := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [literal, literal_1, suite]
        self._reset(mark)
        return None

    @memoize
    def _tmp_104(self) -> Optional[Any]:
        # _tmp_104: ',' with_item
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (with_item := self.with_item())
        ):
            return [literal, with_item]
        self._reset(mark)
        return None

    @memoize
    def _tmp_105(self) -> Optional[Any]:
        # _tmp_105: 'as' NAME
        mark = self._mark()
        if (
            (literal := self.expect('as'))
            and
            (name := self.name())
        ):
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_106(self) -> Optional[Any]:
        # _tmp_106: 'or' and_test
        mark = self._mark()
        if (
            (literal := self.expect('or'))
            and
            (and_test := self.and_test())
        ):
            return [literal, and_test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_107(self) -> Optional[Any]:
        # _tmp_107: 'and' not_test
        mark = self._mark()
        if (
            (literal := self.expect('and'))
            and
            (not_test := self.not_test())
        ):
            return [literal, not_test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_108(self) -> Optional[Any]:
        # _tmp_108: comp_op expr
        mark = self._mark()
        if (
            (comp_op := self.comp_op())
            and
            (expr := self.expr())
        ):
            return [comp_op, expr]
        self._reset(mark)
        return None

    @memoize
    def _tmp_109(self) -> Optional[Any]:
        # _tmp_109: '|' xor_expr
        mark = self._mark()
        if (
            (literal := self.expect('|'))
            and
            (xor_expr := self.xor_expr())
        ):
            return [literal, xor_expr]
        self._reset(mark)
        return None

    @memoize
    def _tmp_110(self) -> Optional[Any]:
        # _tmp_110: '^' and_expr
        mark = self._mark()
        if (
            (literal := self.expect('^'))
            and
            (and_expr := self.and_expr())
        ):
            return [literal, and_expr]
        self._reset(mark)
        return None

    @memoize
    def _tmp_111(self) -> Optional[Any]:
        # _tmp_111: '&' shift_expr
        mark = self._mark()
        if (
            (literal := self.expect('&'))
            and
            (shift_expr := self.shift_expr())
        ):
            return [literal, shift_expr]
        self._reset(mark)
        return None

    @memoize
    def _tmp_112(self) -> Optional[Any]:
        # _tmp_112: ('<<' | '>>') arith_expr
        mark = self._mark()
        if (
            (_tmp_148 := self._tmp_148())
            and
            (arith_expr := self.arith_expr())
        ):
            return [_tmp_148, arith_expr]
        self._reset(mark)
        return None

    @memoize
    def _tmp_113(self) -> Optional[Any]:
        # _tmp_113: ('+' | '-') term
        mark = self._mark()
        if (
            (_tmp_149 := self._tmp_149())
            and
            (term := self.term())
        ):
            return [_tmp_149, term]
        self._reset(mark)
        return None

    @memoize
    def _tmp_114(self) -> Optional[Any]:
        # _tmp_114: ('*' | '@' | '/' | '%' | '//') factor
        mark = self._mark()
        if (
            (_tmp_150 := self._tmp_150())
            and
            (factor := self.factor())
        ):
            return [_tmp_150, factor]
        self._reset(mark)
        return None

    @memoize
    def _loop0_115(self) -> Optional[Any]:
        # _loop0_115: (',' (namedexpr_test | star_expr))
        mark = self._mark()
        children = []
        while (
            (_tmp_151 := self._tmp_151())
        ):
            children.append(_tmp_151)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_116(self) -> Optional[Any]:
        # _tmp_116: ',' subscript
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (subscript := self.subscript())
        ):
            return [literal, subscript]
        self._reset(mark)
        return None

    @memoize
    def _tmp_117(self) -> Optional[Any]:
        # _tmp_117: ',' (expr | star_expr)
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (_tmp_152 := self._tmp_152())
        ):
            return [literal, _tmp_152]
        self._reset(mark)
        return None

    @memoize
    def _tmp_118(self) -> Optional[Any]:
        # _tmp_118: ',' test
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_119(self) -> Optional[Any]:
        # _tmp_119: test ':' test | '**' expr
        mark = self._mark()
        if (
            (test := self.test())
            and
            (literal := self.expect(':'))
            and
            (test_1 := self.test())
        ):
            return [test, literal, test_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (expr := self.expr())
        ):
            return [literal, expr]
        self._reset(mark)
        return None

    @memoize
    def _tmp_120(self) -> Optional[Any]:
        # _tmp_120: comp_for | ((',' (test ':' test | '**' expr)))* ','?
        mark = self._mark()
        if (
            (comp_for := self.comp_for())
        ):
            return comp_for
        self._reset(mark)
        if (
            (_loop0_153 := self._loop0_153(),)
            and
            (opt := self.expect(','),)
        ):
            return [_loop0_153, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_121(self) -> Optional[Any]:
        # _tmp_121: test | star_expr
        mark = self._mark()
        if (
            (test := self.test())
        ):
            return test
        self._reset(mark)
        if (
            (star_expr := self.star_expr())
        ):
            return star_expr
        self._reset(mark)
        return None

    @memoize
    def _tmp_122(self) -> Optional[Any]:
        # _tmp_122: comp_for | ((',' (test | star_expr)))* ','?
        mark = self._mark()
        if (
            (comp_for := self.comp_for())
        ):
            return comp_for
        self._reset(mark)
        if (
            (_loop0_154 := self._loop0_154(),)
            and
            (opt := self.expect(','),)
        ):
            return [_loop0_154, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_123(self) -> Optional[Any]:
        # _tmp_123: ',' argument
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (argument := self.argument())
        ):
            return [literal, argument]
        self._reset(mark)
        return None

    @memoize
    def _tmp_124(self) -> Optional[Any]:
        # _tmp_124: ',' test
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_125(self) -> Optional[Any]:
        # _tmp_125: '*' test? ((',' test))* [',' '**' test] | '**' test
        mark = self._mark()
        if (
            (literal := self.expect('*'))
            and
            (opt := self.test(),)
            and
            (_loop0_155 := self._loop0_155(),)
            and
            (opt_1 := self._tmp_156(),)
        ):
            return [literal, opt, _loop0_155, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_126(self) -> Optional[Any]:
        # _tmp_126: ',' test
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_127(self) -> Optional[Any]:
        # _tmp_127: ',' TYPE_COMMENT? tfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (tfpdef := self.tfpdef())
            and
            (opt_1 := self._tmp_157(),)
        ):
            return [literal, opt, tfpdef, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_128(self) -> Optional[Any]:
        # _tmp_128: TYPE_COMMENT? tfpdef ['=' test] ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]) | '*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?
        mark = self._mark()
        if (
            (opt := self.type_comment(),)
            and
            (tfpdef := self.tfpdef())
            and
            (opt_1 := self._tmp_158(),)
            and
            (_loop0_159 := self._loop0_159(),)
            and
            (_tmp_160 := self._tmp_160())
        ):
            return [opt, tfpdef, opt_1, _loop0_159, _tmp_160]
        self._reset(mark)
        if (
            (literal := self.expect('*'))
            and
            (opt := self.tfpdef(),)
            and
            (_loop0_161 := self._loop0_161(),)
            and
            (_tmp_162 := self._tmp_162())
        ):
            return [literal, opt, _loop0_161, _tmp_162]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (tfpdef := self.tfpdef())
            and
            (opt := self.expect(','),)
            and
            (opt_1 := self.type_comment(),)
        ):
            return [literal, tfpdef, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_129(self) -> Optional[Any]:
        # _tmp_129: ',' TYPE_COMMENT? tfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (tfpdef := self.tfpdef())
            and
            (opt_1 := self._tmp_163(),)
        ):
            return [literal, opt, tfpdef, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_130(self) -> Optional[Any]:
        # _tmp_130: ',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (opt_1 := self._tmp_164(),)
        ):
            return [literal, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_131(self) -> Optional[Any]:
        # _tmp_131: ',' TYPE_COMMENT? tfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (tfpdef := self.tfpdef())
            and
            (opt_1 := self._tmp_165(),)
        ):
            return [literal, opt, tfpdef, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_132(self) -> Optional[Any]:
        # _tmp_132: ',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (opt_1 := self._tmp_166(),)
        ):
            return [literal, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_133(self) -> Optional[Any]:
        # _tmp_133: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_134(self) -> Optional[Any]:
        # _tmp_134: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_135(self) -> Optional[Any]:
        # _loop0_135: (',' vfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_167 := self._tmp_167())
        ):
            children.append(_tmp_167)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_136(self) -> Optional[Any]:
        # _tmp_136: ',' ['*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_168(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop0_137(self) -> Optional[Any]:
        # _loop0_137: (',' vfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_169 := self._tmp_169())
        ):
            children.append(_tmp_169)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_138(self) -> Optional[Any]:
        # _tmp_138: ',' ['**' vfpdef ','?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_170(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_139(self) -> Optional[Any]:
        # _tmp_139: ',' vfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_171(),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_140(self) -> Optional[Any]:
        # _tmp_140: '*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?
        mark = self._mark()
        if (
            (literal := self.expect('*'))
            and
            (opt := self.vfpdef(),)
            and
            (_loop0_172 := self._loop0_172(),)
            and
            (opt_1 := self._tmp_173(),)
        ):
            return [literal, opt, _loop0_172, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self.expect(','),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_141(self) -> Optional[Any]:
        # _tmp_141: ',' vfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_174(),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_142(self) -> Optional[Any]:
        # _tmp_142: '**' vfpdef ','?
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self.expect(','),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _loop1_143(self) -> Optional[Any]:
        # _loop1_143: ('=' (yield_expr | testlist_star_expr))
        mark = self._mark()
        children = []
        while (
            (_tmp_175 := self._tmp_175())
        ):
            children.append(_tmp_175)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_144(self) -> Optional[Any]:
        # _tmp_144: test | star_expr
        mark = self._mark()
        if (
            (test := self.test())
        ):
            return test
        self._reset(mark)
        if (
            (star_expr := self.star_expr())
        ):
            return star_expr
        self._reset(mark)
        return None

    @memoize
    def _tmp_145(self) -> Optional[Any]:
        # _tmp_145: '.' | '...'
        mark = self._mark()
        if (
            (literal := self.expect('.'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('...'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_146(self) -> Optional[Any]:
        # _tmp_146: '.' | '...'
        mark = self._mark()
        if (
            (literal := self.expect('.'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('...'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_147(self) -> Optional[Any]:
        # _tmp_147: except_clause ':' suite
        mark = self._mark()
        if (
            (except_clause := self.except_clause())
            and
            (literal := self.expect(':'))
            and
            (suite := self.suite())
        ):
            return [except_clause, literal, suite]
        self._reset(mark)
        return None

    @memoize
    def _tmp_148(self) -> Optional[Any]:
        # _tmp_148: '<<' | '>>'
        mark = self._mark()
        if (
            (literal := self.expect('<<'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('>>'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_149(self) -> Optional[Any]:
        # _tmp_149: '+' | '-'
        mark = self._mark()
        if (
            (literal := self.expect('+'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('-'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_150(self) -> Optional[Any]:
        # _tmp_150: '*' | '@' | '/' | '%' | '//'
        mark = self._mark()
        if (
            (literal := self.expect('*'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('@'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('/'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('%'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('//'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_151(self) -> Optional[Any]:
        # _tmp_151: ',' (namedexpr_test | star_expr)
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (_tmp_176 := self._tmp_176())
        ):
            return [literal, _tmp_176]
        self._reset(mark)
        return None

    @memoize
    def _tmp_152(self) -> Optional[Any]:
        # _tmp_152: expr | star_expr
        mark = self._mark()
        if (
            (expr := self.expr())
        ):
            return expr
        self._reset(mark)
        if (
            (star_expr := self.star_expr())
        ):
            return star_expr
        self._reset(mark)
        return None

    @memoize
    def _loop0_153(self) -> Optional[Any]:
        # _loop0_153: (',' (test ':' test | '**' expr))
        mark = self._mark()
        children = []
        while (
            (_tmp_177 := self._tmp_177())
        ):
            children.append(_tmp_177)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_154(self) -> Optional[Any]:
        # _loop0_154: (',' (test | star_expr))
        mark = self._mark()
        children = []
        while (
            (_tmp_178 := self._tmp_178())
        ):
            children.append(_tmp_178)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_155(self) -> Optional[Any]:
        # _loop0_155: (',' test)
        mark = self._mark()
        children = []
        while (
            (_tmp_179 := self._tmp_179())
        ):
            children.append(_tmp_179)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_156(self) -> Optional[Any]:
        # _tmp_156: ',' '**' test
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('**'))
            and
            (test := self.test())
        ):
            return [literal, literal_1, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_157(self) -> Optional[Any]:
        # _tmp_157: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_158(self) -> Optional[Any]:
        # _tmp_158: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_159(self) -> Optional[Any]:
        # _loop0_159: (',' TYPE_COMMENT? tfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_180 := self._tmp_180())
        ):
            children.append(_tmp_180)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_160(self) -> Optional[Any]:
        # _tmp_160: TYPE_COMMENT | [',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]]
        mark = self._mark()
        if (
            (type_comment := self.type_comment())
        ):
            return type_comment
        self._reset(mark)
        if (
            (opt := self._tmp_181(),)
        ):
            return opt
        self._reset(mark)
        return None

    @memoize
    def _loop0_161(self) -> Optional[Any]:
        # _loop0_161: (',' TYPE_COMMENT? tfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_182 := self._tmp_182())
        ):
            children.append(_tmp_182)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_162(self) -> Optional[Any]:
        # _tmp_162: TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]
        mark = self._mark()
        if (
            (type_comment := self.type_comment())
        ):
            return type_comment
        self._reset(mark)
        if (
            (opt := self._tmp_183(),)
        ):
            return opt
        self._reset(mark)
        return None

    @memoize
    def _tmp_163(self) -> Optional[Any]:
        # _tmp_163: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_164(self) -> Optional[Any]:
        # _tmp_164: '*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?
        mark = self._mark()
        if (
            (literal := self.expect('*'))
            and
            (opt := self.tfpdef(),)
            and
            (_loop0_184 := self._loop0_184(),)
            and
            (_tmp_185 := self._tmp_185())
        ):
            return [literal, opt, _loop0_184, _tmp_185]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (tfpdef := self.tfpdef())
            and
            (opt := self.expect(','),)
            and
            (opt_1 := self.type_comment(),)
        ):
            return [literal, tfpdef, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_165(self) -> Optional[Any]:
        # _tmp_165: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_166(self) -> Optional[Any]:
        # _tmp_166: '**' tfpdef ','? TYPE_COMMENT?
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (tfpdef := self.tfpdef())
            and
            (opt := self.expect(','),)
            and
            (opt_1 := self.type_comment(),)
        ):
            return [literal, tfpdef, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_167(self) -> Optional[Any]:
        # _tmp_167: ',' vfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_186(),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_168(self) -> Optional[Any]:
        # _tmp_168: '*' vfpdef? ((',' vfpdef ['=' test]))* [',' ['**' vfpdef ','?]] | '**' vfpdef ','?
        mark = self._mark()
        if (
            (literal := self.expect('*'))
            and
            (opt := self.vfpdef(),)
            and
            (_loop0_187 := self._loop0_187(),)
            and
            (opt_1 := self._tmp_188(),)
        ):
            return [literal, opt, _loop0_187, opt_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self.expect(','),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_169(self) -> Optional[Any]:
        # _tmp_169: ',' vfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_189(),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_170(self) -> Optional[Any]:
        # _tmp_170: '**' vfpdef ','?
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self.expect(','),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_171(self) -> Optional[Any]:
        # _tmp_171: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_172(self) -> Optional[Any]:
        # _loop0_172: (',' vfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_190 := self._tmp_190())
        ):
            children.append(_tmp_190)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_173(self) -> Optional[Any]:
        # _tmp_173: ',' ['**' vfpdef ','?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_191(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_174(self) -> Optional[Any]:
        # _tmp_174: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_175(self) -> Optional[Any]:
        # _tmp_175: '=' (yield_expr | testlist_star_expr)
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (_tmp_192 := self._tmp_192())
        ):
            return [literal, _tmp_192]
        self._reset(mark)
        return None

    @memoize
    def _tmp_176(self) -> Optional[Any]:
        # _tmp_176: namedexpr_test | star_expr
        mark = self._mark()
        if (
            (namedexpr_test := self.namedexpr_test())
        ):
            return namedexpr_test
        self._reset(mark)
        if (
            (star_expr := self.star_expr())
        ):
            return star_expr
        self._reset(mark)
        return None

    @memoize
    def _tmp_177(self) -> Optional[Any]:
        # _tmp_177: ',' (test ':' test | '**' expr)
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (_tmp_193 := self._tmp_193())
        ):
            return [literal, _tmp_193]
        self._reset(mark)
        return None

    @memoize
    def _tmp_178(self) -> Optional[Any]:
        # _tmp_178: ',' (test | star_expr)
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (_tmp_194 := self._tmp_194())
        ):
            return [literal, _tmp_194]
        self._reset(mark)
        return None

    @memoize
    def _tmp_179(self) -> Optional[Any]:
        # _tmp_179: ',' test
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_180(self) -> Optional[Any]:
        # _tmp_180: ',' TYPE_COMMENT? tfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (tfpdef := self.tfpdef())
            and
            (opt_1 := self._tmp_195(),)
        ):
            return [literal, opt, tfpdef, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_181(self) -> Optional[Any]:
        # _tmp_181: ',' TYPE_COMMENT? ['*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (opt_1 := self._tmp_196(),)
        ):
            return [literal, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_182(self) -> Optional[Any]:
        # _tmp_182: ',' TYPE_COMMENT? tfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (tfpdef := self.tfpdef())
            and
            (opt_1 := self._tmp_197(),)
        ):
            return [literal, opt, tfpdef, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_183(self) -> Optional[Any]:
        # _tmp_183: ',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (opt_1 := self._tmp_198(),)
        ):
            return [literal, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _loop0_184(self) -> Optional[Any]:
        # _loop0_184: (',' TYPE_COMMENT? tfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_199 := self._tmp_199())
        ):
            children.append(_tmp_199)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_185(self) -> Optional[Any]:
        # _tmp_185: TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]
        mark = self._mark()
        if (
            (type_comment := self.type_comment())
        ):
            return type_comment
        self._reset(mark)
        if (
            (opt := self._tmp_200(),)
        ):
            return opt
        self._reset(mark)
        return None

    @memoize
    def _tmp_186(self) -> Optional[Any]:
        # _tmp_186: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_187(self) -> Optional[Any]:
        # _loop0_187: (',' vfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_201 := self._tmp_201())
        ):
            children.append(_tmp_201)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_188(self) -> Optional[Any]:
        # _tmp_188: ',' ['**' vfpdef ','?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self._tmp_202(),)
        ):
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_189(self) -> Optional[Any]:
        # _tmp_189: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_190(self) -> Optional[Any]:
        # _tmp_190: ',' vfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_203(),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_191(self) -> Optional[Any]:
        # _tmp_191: '**' vfpdef ','?
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self.expect(','),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_192(self) -> Optional[Any]:
        # _tmp_192: yield_expr | testlist_star_expr
        mark = self._mark()
        if (
            (yield_expr := self.yield_expr())
        ):
            return yield_expr
        self._reset(mark)
        if (
            (testlist_star_expr := self.testlist_star_expr())
        ):
            return testlist_star_expr
        self._reset(mark)
        return None

    @memoize
    def _tmp_193(self) -> Optional[Any]:
        # _tmp_193: test ':' test | '**' expr
        mark = self._mark()
        if (
            (test := self.test())
            and
            (literal := self.expect(':'))
            and
            (test_1 := self.test())
        ):
            return [test, literal, test_1]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (expr := self.expr())
        ):
            return [literal, expr]
        self._reset(mark)
        return None

    @memoize
    def _tmp_194(self) -> Optional[Any]:
        # _tmp_194: test | star_expr
        mark = self._mark()
        if (
            (test := self.test())
        ):
            return test
        self._reset(mark)
        if (
            (star_expr := self.star_expr())
        ):
            return star_expr
        self._reset(mark)
        return None

    @memoize
    def _tmp_195(self) -> Optional[Any]:
        # _tmp_195: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_196(self) -> Optional[Any]:
        # _tmp_196: '*' tfpdef? ((',' TYPE_COMMENT? tfpdef ['=' test]))* (TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]) | '**' tfpdef ','? TYPE_COMMENT?
        mark = self._mark()
        if (
            (literal := self.expect('*'))
            and
            (opt := self.tfpdef(),)
            and
            (_loop0_204 := self._loop0_204(),)
            and
            (_tmp_205 := self._tmp_205())
        ):
            return [literal, opt, _loop0_204, _tmp_205]
        self._reset(mark)
        if (
            (literal := self.expect('**'))
            and
            (tfpdef := self.tfpdef())
            and
            (opt := self.expect(','),)
            and
            (opt_1 := self.type_comment(),)
        ):
            return [literal, tfpdef, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_197(self) -> Optional[Any]:
        # _tmp_197: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_198(self) -> Optional[Any]:
        # _tmp_198: '**' tfpdef ','? TYPE_COMMENT?
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (tfpdef := self.tfpdef())
            and
            (opt := self.expect(','),)
            and
            (opt_1 := self.type_comment(),)
        ):
            return [literal, tfpdef, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_199(self) -> Optional[Any]:
        # _tmp_199: ',' TYPE_COMMENT? tfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (tfpdef := self.tfpdef())
            and
            (opt_1 := self._tmp_206(),)
        ):
            return [literal, opt, tfpdef, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_200(self) -> Optional[Any]:
        # _tmp_200: ',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (opt_1 := self._tmp_207(),)
        ):
            return [literal, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_201(self) -> Optional[Any]:
        # _tmp_201: ',' vfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self._tmp_208(),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_202(self) -> Optional[Any]:
        # _tmp_202: '**' vfpdef ','?
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (vfpdef := self.vfpdef())
            and
            (opt := self.expect(','),)
        ):
            return [literal, vfpdef, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_203(self) -> Optional[Any]:
        # _tmp_203: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _loop0_204(self) -> Optional[Any]:
        # _loop0_204: (',' TYPE_COMMENT? tfpdef ['=' test])
        mark = self._mark()
        children = []
        while (
            (_tmp_209 := self._tmp_209())
        ):
            children.append(_tmp_209)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_205(self) -> Optional[Any]:
        # _tmp_205: TYPE_COMMENT | [',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]]
        mark = self._mark()
        if (
            (type_comment := self.type_comment())
        ):
            return type_comment
        self._reset(mark)
        if (
            (opt := self._tmp_210(),)
        ):
            return opt
        self._reset(mark)
        return None

    @memoize
    def _tmp_206(self) -> Optional[Any]:
        # _tmp_206: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_207(self) -> Optional[Any]:
        # _tmp_207: '**' tfpdef ','? TYPE_COMMENT?
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (tfpdef := self.tfpdef())
            and
            (opt := self.expect(','),)
            and
            (opt_1 := self.type_comment(),)
        ):
            return [literal, tfpdef, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_208(self) -> Optional[Any]:
        # _tmp_208: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_209(self) -> Optional[Any]:
        # _tmp_209: ',' TYPE_COMMENT? tfpdef ['=' test]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (tfpdef := self.tfpdef())
            and
            (opt_1 := self._tmp_211(),)
        ):
            return [literal, opt, tfpdef, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_210(self) -> Optional[Any]:
        # _tmp_210: ',' TYPE_COMMENT? ['**' tfpdef ','? TYPE_COMMENT?]
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (opt := self.type_comment(),)
            and
            (opt_1 := self._tmp_212(),)
        ):
            return [literal, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_211(self) -> Optional[Any]:
        # _tmp_211: '=' test
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (test := self.test())
        ):
            return [literal, test]
        self._reset(mark)
        return None

    @memoize
    def _tmp_212(self) -> Optional[Any]:
        # _tmp_212: '**' tfpdef ','? TYPE_COMMENT?
        mark = self._mark()
        if (
            (literal := self.expect('**'))
            and
            (tfpdef := self.tfpdef())
            and
            (opt := self.expect(','),)
            and
            (opt_1 := self.type_comment(),)
        ):
            return [literal, tfpdef, opt, opt_1]
        self._reset(mark)
        return None

    KEYWORDS = ('continue', 'None', 'try', 'while', 'pass', 'elif', 'nonlocal', 'True', 'raise', 'finally', 'for', 'as', 'and', 'del', 'except', 'if', 'lambda', 'not', 'is', 'in', 'class', 'return', 'from', 'assert', 'yield', 'def', 'global', 'with', 'or', 'import', 'break', 'else', 'False')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
